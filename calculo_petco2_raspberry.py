# -*- coding: utf-8 -*-
"""Calculo_PETCO2_Raspberry.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G5YNbV-W8KuHO09PAic6nbHflYPZ3cXP
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from pylab import *
import scipy.signal as signal
from scipy.signal import savgol_filter
from scipy.signal import find_peaks
import numpy.ma as ma
import random

from google.colab import drive
drive.mount("/content/gdrive")

import glob
df2, names=[],[]    
files = glob.glob("/content/gdrive/My Drive/Colab Notebooks/Datasets/Capnobase/*.csv")##falta la ubicación del archivo
for a in files:
        df1= pd.read_csv(a)
        df1.name = a
        nsplit = df1.name
        nsplit = nsplit.split("/")
        nsplit = nsplit[-1]
        df2.append(df1)
        names.append(nsplit)

dft = pd.read_excel('/content/gdrive/My Drive/Colab Notebooks/Datasets/Capnobase/0009_8min_signal.xlsx')

def PetCo2segtst_df (y):
    
    ##Smooth sobre señal original
    yhat = savgol_filter(y, 61, 3) # window size 61, polynomial order 3
    
    ##derivadas de la señal filtrada
    y1hat_= np.diff(yhat)
        
    ##picos de la primera derivada
    y1hat_x= -y1hat_ #Invertimos la señal sobre su eje (y)
    peaks, _ = find_peaks(y1hat_x, height=0.025)
    #print(peaks)

    mCO2 = []
    indice=[]
    for j in range(peaks.shape[0]-1):
      peak1, peak2, peak3 = [],[],[]
      if (peaks[j+1] - peaks[j]) < 100:
        peak1.append(peaks[j])
        peak1.append(peaks[j+1])
        #print(peak1)
      else:
        peak2.append(peaks[j])
        peak2.append(peaks[j+1])
        indice.append(j) #guardamos la posición que separa cada pico    
      peak3 = np.unique(peak1 + peak2)
      mCO2.append(peak3)
      
    #print(mCO2)

    lst = np.argwhere(peaks == peaks[-1])
    indice.append(lst.item())
    
    #print(indice)
    
    list1, list2, listf= [],[],[]
    for j in range(len(indice)):
      if j == 0:
        list1 = sorted(np.unique(mCO2[0:indice[0]]))
        #print(list1)
      else:
        list2 = sorted(np.unique(mCO2[indice[j-1]:indice[j]]))
        #print(j,list2)
      
      listf.append(list2)
    listf [0] = list1 #valores en x de los picos
    #print(listf)

    ##máximo entre picos#####
    #Guardamos en test el último valor en la lista de cada pico 
    testf =[]
    for j in range(len(listf)):
      if (j==0 & (len(listf[j]))==0):
        test= peaks[0]
      elif (j==(len(listf)) & (len(listf[j]))==0):
        test= peaks[-1]
      else:
        test= listf[j][-1]
      testf.append(test)
        
    #print(testf)

    #Guarda en harmon todos los valores de yhat entre cada pico
    PetCO2s= []
    for j in range(len(testf)-1):
      if ((testf[j+1]-testf[j])>300 & (testf[j+1] != testf[-1])):
        harmon = (yhat[testf[j]: testf[j+1]]* 7.50062)
        yhmx= max(harmon)#máximo del armónico
        xhmx= np.argmax(harmon)#indice del máximo del armónico
        #cmax = harmon[(xhmx+10) : -1].max()
        #xcmax = np.argmax(harmon[(xhmx+1) : -1])

        #tomamos todos los valores de harmon entre 5 datos posterior al máximo y 
        #el final de la lista con una dif menor a 0.33 respecto al máximo
        mxmean = np.mean([j for j in harmon[(xhmx+5) : -1] if (yhmx-j) < 0.33])
        mxmean = np.round(mxmean, decimals = 2)
        #mxmean2 = bisect(harmon, mxmean)#encontramos el valor en harmon más cercano 
                                        #a mxmean
      else: 
        harmon = (yhat[testf[j+1]: testf[j+2]]* 7.50062)
        yhmx= max(harmon)#máximo del armónico
        xhmx= np.argmax(harmon)#indice del máximo del armónico
        mxmean = np.mean([j for j in harmon[(xhmx+5) : -1] if (yhmx-j) < 0.33])
        mxmean = np.round(mxmean, decimals = 2)
        
      PetCO2s.append(mxmean)
    PetCO2s = [x for x in PetCO2s if np.isnan(x) == False]

    #Creamos una lista con el segmento, su media, mediana y valores de PetCO2 
    PetCO2s_mean =  np.round(mean(PetCO2s), decimals = 2)
    PetCO2s_median = median(PetCO2s)
    
  
    # return PetCO2s, PetCO2s_mean, PetCO2s_median
    return PetCO2s_median

div=18 #divisiones de la señal
df_c = dft.iloc[: , 0]#tomamos únicamente los datos de capnografía
y= np.array_split(df_c, div)#splits the data in n parts 
y= y[4] #segmento de la señal que tomamos
y[np.isnan(y)] = np.median(y[~np.isnan(y)])

### Nota: En la Raspberry (y) corresponde a los datos tomados por el sensor

PetCo2segtst_df (y)

